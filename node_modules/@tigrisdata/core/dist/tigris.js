"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tigris = void 0;
const api_grpc_pb_1 = require("./proto/server/v1/api_grpc_pb");
const grpc = __importStar(require("@grpc/grpc-js"));
const grpc_js_1 = require("@grpc/grpc-js");
const api_pb_1 = require("./proto/server/v1/api_pb");
const types_1 = require("./types");
const auth_pb_1 = require("./proto/server/v1/auth_pb");
const db_1 = require("./db");
const auth_grpc_pb_1 = require("./proto/server/v1/auth_grpc_pb");
const utility_1 = require("./utility");
const AuthorizationHeaderName = "authorization";
const AuthorizationBearer = "Bearer ";
class TokenSupplier {
    constructor(config) {
        this.authClient = new auth_grpc_pb_1.AuthClient(config.serverUrl, grpc.credentials.createSsl());
        this.applicationId = config.applicationId;
        this.applicationSecret = config.applicationSecret;
    }
    getAccessToken() {
        return new Promise((resolve, reject) => {
            if (this.shouldRefresh()) {
                // refresh
                this.authClient.getAccessToken(new auth_pb_1.GetAccessTokenRequest()
                    .setGrantType(auth_pb_1.GrantType.CLIENT_CREDENTIALS)
                    .setClientId(this.applicationId)
                    .setClientSecret(this.applicationSecret), (error, response) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        this.accessToken = response.getAccessToken();
                        // retrieve exp
                        const parts = this.accessToken.split(".");
                        const exp = Number(utility_1.Utility.jsonStringToObj(utility_1.Utility._base64Decode(parts[1]))["exp"]);
                        // 5 min before expiry (note: exp is in seconds)
                        // add random jitter of 1-5 min (i.e. 60000 - 300000 ms)
                        this.nextRefreshTime = (exp * 1000) - 300000 - (utility_1.Utility._getRandomInt(300000) + 60000);
                        resolve(this.accessToken);
                    }
                });
            }
            else {
                resolve(this.accessToken);
            }
        });
    }
    shouldRefresh() {
        if (typeof this.accessToken === "undefined") {
            return true;
        }
        return Date.now() >= this.nextRefreshTime;
    }
}
/**
 * Tigris client
 */
class Tigris {
    /**
     *
     * @param  {TigrisClientConfig} config configuration
     */
    constructor(config) {
        if (config.insecureChannel === true && config.applicationSecret === undefined) {
            // no auth & insecure channel
            this.grpcClient = new api_grpc_pb_1.TigrisClient(config.serverUrl, grpc.credentials.createInsecure());
        }
        else if ((config.insecureChannel === undefined || config.insecureChannel == false) && config.applicationSecret === undefined) {
            // no auth & secure channel
            this.grpcClient = new api_grpc_pb_1.TigrisClient(config.serverUrl, grpc.credentials.createSsl());
        }
        else if ((config.insecureChannel === undefined || config.insecureChannel) && config.applicationSecret !== undefined) {
            // auth & insecure channel
            console.error("Passing token on insecure channel is not allowed");
            process.exitCode = 1;
        }
        else {
            // auth & secure channel
            const tokenSupplier = new TokenSupplier(config);
            this.grpcClient = new api_grpc_pb_1.TigrisClient(config.serverUrl, grpc.credentials.combineChannelCredentials(grpc.credentials.createSsl(), grpc.credentials.createFromMetadataGenerator((params, callback) => {
                tokenSupplier.getAccessToken()
                    .then(accessToken => {
                    const md = new grpc.Metadata();
                    md.set(AuthorizationHeaderName, AuthorizationBearer + accessToken);
                    return callback(undefined, md);
                })
                    .catch(error => {
                    return callback(error);
                });
            })));
        }
    }
    /**
     * Lists the databases
     * @return {Promise<Array<DatabaseInfo>>} a promise of an array of
     * DatabaseInfo
     */
    listDatabases() {
        return new Promise((resolve, reject) => {
            this.grpcClient.listDatabases(new api_pb_1.ListDatabasesRequest(), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const result = response
                        .getDatabasesList()
                        .map((protoDatabaseInfo) => new types_1.DatabaseInfo(protoDatabaseInfo.getDb(), new types_1.DatabaseMetadata()));
                    resolve(result);
                }
            });
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    createDatabaseIfNotExists(db, _options) {
        return new Promise((resolve, reject) => {
            this.grpcClient.createDatabase(new api_pb_1.CreateDatabaseRequest().setDb(db).setOptions(new api_pb_1.DatabaseOptions()), 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (error, _response) => {
                if (error && error.code != grpc_js_1.status.ALREADY_EXISTS) {
                    reject(error);
                }
                else {
                    resolve(new db_1.DB(db, this.grpcClient));
                }
            });
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dropDatabase(db, _options) {
        return new Promise((resolve, reject) => {
            this.grpcClient.dropDatabase(new api_pb_1.DropDatabaseRequest().setDb(db).setOptions(new api_pb_1.DatabaseOptions()), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.DropDatabaseResponse(response.getStatus(), response.getMessage()));
                }
            });
        });
    }
    getDatabase(db) {
        return new db_1.DB(db, this.grpcClient);
    }
    getServerMetadata() {
        return new Promise((resolve, reject) => {
            this.grpcClient.getInfo(new api_pb_1.GetInfoRequest(), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.ServerMetadata(response.getServerVersion()));
                }
            });
        });
    }
}
exports.Tigris = Tigris;
/**
 * Default instance of the Tigris client
 */
exports.default = new Tigris({ serverUrl: `${process.env.TIGRIS_SERVER_URL}` });
