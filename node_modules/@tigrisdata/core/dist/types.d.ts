export declare class DatabaseInfo {
    private readonly _name;
    private readonly _metadata;
    constructor(name: string, metadata: DatabaseMetadata);
    get name(): string;
    get metadata(): DatabaseMetadata;
}
export declare class CollectionInfo {
    private readonly _name;
    private readonly _metadata;
    constructor(name: string, metadata: CollectionMetadata);
    get name(): string;
    get metadata(): CollectionMetadata;
}
export declare class DatabaseMetadata {
}
export declare class CollectionMetadata {
}
export declare class DatabaseOptions {
}
export declare class CollectionOptions {
}
export declare class DropDatabaseResponse {
    private readonly _status;
    private readonly _message;
    constructor(status: string, message: string);
    get status(): string;
    get message(): string;
}
export declare class DropCollectionResponse {
    private readonly _status;
    private readonly _message;
    constructor(status: string, message: string);
    get status(): string;
    get message(): string;
}
export declare class DatabaseDescription {
    private readonly _db;
    private readonly _metadata;
    private readonly _collectionsDescription;
    constructor(db: string, metadata: DatabaseMetadata, collectionsDescription: Array<CollectionDescription>);
    get db(): string;
    get metadata(): DatabaseMetadata;
    get collectionsDescription(): Array<CollectionDescription>;
}
export declare class CollectionDescription {
    private readonly _collection;
    private readonly _metadata;
    private readonly _schema;
    constructor(collection: string, metadata: CollectionMetadata, schema: string);
    get collection(): string;
    get metadata(): CollectionMetadata;
    get schema(): string;
}
export declare class TigrisResponse {
    private readonly _status;
    constructor(status: string);
    get status(): string;
}
export declare class DMLMetadata {
    private readonly _createdAt;
    private readonly _updatedAt;
    constructor(createdAt: Date, updatedAt: Date);
    get createdAt(): Date;
    get updatedAt(): Date;
}
export declare class DMLResponse extends TigrisResponse {
    private readonly _metadata;
    constructor(status: string, metadata: DMLMetadata);
    get metadata(): DMLMetadata;
}
export declare class DeleteResponse extends DMLResponse {
    constructor(status: string, metadata: DMLMetadata);
}
export declare class UpdateResponse extends DMLResponse {
    constructor(status: string, metadata: DMLMetadata);
}
export declare class WriteOptions {
}
export declare class DeleteRequestOptions {
}
export declare class ReadRequestOptions {
    static DEFAULT_LIMIT: number;
    static DEFAULT_SKIP: number;
    private _limit;
    private _skip;
    private _offset;
    constructor(limit?: number);
    constructor(limit: number, skip: number);
    get limit(): number;
    set limit(value: number);
    get skip(): number;
    set skip(value: number);
    get offset(): string;
    set offset(value: string);
}
export declare class UpdateRequestOptions {
}
export declare class TransactionOptions {
}
export declare class EventsRequestOptions {
}
export declare class StreamEvent<T> {
    private readonly _txId;
    private readonly _collection;
    private readonly _op;
    private readonly _data;
    private readonly _last;
    constructor(txId: string, collection: string, op: string, data: T, last: boolean);
    get txId(): string;
    get collection(): string;
    get op(): string;
    get data(): T;
    get last(): boolean;
}
export declare class CommitTransactionResponse extends TigrisResponse {
    constructor(status: string);
}
export declare class RollbackTransactionResponse extends TigrisResponse {
    constructor(status: string);
}
export declare class TransactionResponse extends TigrisResponse {
    constructor(status: string);
}
export declare class InsertOptions {
}
export declare class PublishOptions {
}
export declare class InsertOrReplaceOptions {
}
export declare class ServerMetadata {
    private readonly _serverVersion;
    constructor(serverVersion: string);
    get serverVersion(): string;
}
export interface TigrisCollectionType {
}
export interface TigrisTopicType {
}
export declare enum LogicalOperator {
    AND = "$and",
    OR = "$or"
}
export declare enum SelectorFilterOperator {
    EQ = "$eq",
    LT = "$lt",
    LTE = "$lte",
    GT = "$gt",
    GTE = "$gte",
    NONE = "$none"
}
export declare enum UpdateFieldsOperator {
    SET = "$set"
}
export declare type FieldTypes = string | number | boolean | bigint | BigInteger;
export declare type LogicalFilter<T> = {
    op: LogicalOperator;
    selectorFilters?: Array<SelectorFilter<T> | Selector<T>>;
    logicalFilters?: Array<LogicalFilter<T>>;
};
export declare type ReadFields = {
    include?: Array<string>;
    exclude?: Array<string>;
};
export declare type UpdateFields = {
    op: UpdateFieldsOperator;
    fields: SimpleUpdateField;
};
export declare type SimpleUpdateField = {
    [key: string]: FieldTypes | undefined;
};
export declare enum TigrisDataTypes {
    STRING = "string",
    INT32 = "int32",
    INT64 = "int64",
    NUMBER = "number",
    NUMBER_BIGINT = "bigint",
    DATE_TIME = "date-time",
    BYTE_STRING = "byte-string",
    UUID = "uuid",
    ARRAY = "array"
}
export declare type TigrisSchema<T> = {
    [K in keyof T]: ({
        type: (TigrisDataTypes | TigrisSchema<unknown>);
        primary_key?: TigrisPrimaryKey;
        items?: TigrisArrayItem;
    });
};
export declare type TigrisArrayItem = {
    type: TigrisDataTypes | TigrisSchema<unknown>;
    items?: TigrisArrayItem | TigrisDataTypes;
};
export declare type TigrisPrimaryKey = {
    order: number;
    autoGenerate?: boolean;
};
/**
Generates all possible paths for type parameter T. By recursively iterating over its keys. While
 iterating the keys it makes the keys available in string form and in non string form both. For
 example

 interface IUser {
  name: string;
  id: number
  address: Address;
 }

 interface Address {
  city: string
  state: string
 }

 and Paths<IUser> will make these keys available
 name, id, address (object type) and also in the string form
 "name", "id", "address.city", "address.state"

 */
declare type Paths<T, P extends string = ""> = {
    [K in keyof T]: T[K] extends object ? T[K] extends unknown[] ? `${P}${K & string}` : Paths<T[K], `${P}${K & string}.`> extends infer O ? `${O & string}` | `${P}${K & string}` : never : `${P}${K & string}`;
}[keyof T];
/**
 * This type helps to infer the type of the path that Paths (above) has generated.
 */
declare type PathType<T, P extends string> = P extends keyof T ? T[P] : P extends `${infer L}.${infer R}` ? L extends keyof T ? PathType<T[L], R> : never : never;
export declare type Selector<T> = Partial<{
    [K in Paths<T>]: Partial<PathType<T, K & string>>;
}>;
export declare type SelectorFilter<T> = Partial<{
    op?: SelectorFilterOperator;
    fields: Selector<T>;
}>;
export {};
