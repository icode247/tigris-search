"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utility = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const json_bigint_1 = __importDefault(require("json-bigint"));
const types_1 = require("./types");
const fs = __importStar(require("node:fs"));
const types_2 = require("./search/types");
const api_pb_1 = require("./proto/server/v1/api_pb");
exports.Utility = {
    stringToUint8Array(input) {
        return new TextEncoder().encode(input);
    },
    uint8ArrayToString(input) {
        return new TextDecoder().decode(input);
    },
    filterToString(filter) {
        // eslint-disable-next-line no-prototype-builtins
        if (filter.hasOwnProperty("op") && (filter["op"] === types_1.LogicalOperator.AND || filter["op"] === types_1.LogicalOperator.OR)) {
            // LogicalFilter
            return exports.Utility._logicalFilterToString(filter);
            // eslint-disable-next-line no-prototype-builtins
        }
        else if (filter.hasOwnProperty("op")) {
            // SelectorFilter
            return exports.Utility._selectorFilterToString(filter);
        }
        else {
            // Selector (default operator $eq)
            return exports.Utility.objToJsonString(filter);
        }
    },
    _getRandomInt(upperBound) {
        return Math.floor(Math.random() * upperBound);
    },
    _selectorFilterToString(filter) {
        switch (filter.op) {
            case types_1.SelectorFilterOperator.NONE:
                // filter nothing
                return "{}";
            case types_1.SelectorFilterOperator.EQ:
            case types_1.SelectorFilterOperator.LT:
            case types_1.SelectorFilterOperator.LTE:
            case types_1.SelectorFilterOperator.GT:
            case types_1.SelectorFilterOperator.GTE:
                return exports.Utility.objToJsonString(exports.Utility._selectorFilterToFlatJSONObj(filter.op, filter.fields));
            default:
                return "";
        }
    },
    _selectorFilterToFlatJSONObj(op, fields) {
        switch (op) {
            case types_1.SelectorFilterOperator.NONE:
                return {};
            case types_1.SelectorFilterOperator.EQ:
                return exports.Utility._flattenObj(fields);
            case types_1.SelectorFilterOperator.LT:
            case types_1.SelectorFilterOperator.LTE:
            case types_1.SelectorFilterOperator.GT:
            case types_1.SelectorFilterOperator.GTE: {
                const flattenedFields = exports.Utility._flattenObj(fields);
                for (const key in flattenedFields) {
                    flattenedFields[key] = { [op]: flattenedFields[key] };
                }
                return flattenedFields;
            }
            default:
                return exports.Utility._flattenObj(fields);
        }
    },
    _logicalFilterToString(filter) {
        return this.objToJsonString(exports.Utility._logicalFilterToJSONObj(filter));
    },
    _logicalFilterToJSONObj(filter) {
        const result = {};
        const innerFilters = [];
        result[filter.op] = innerFilters;
        if (filter.selectorFilters) {
            for (const value of filter.selectorFilters) {
                // eslint-disable-next-line no-prototype-builtins
                if (value.hasOwnProperty("op")) {
                    const v = value;
                    innerFilters.push(exports.Utility._selectorFilterToFlatJSONObj(v.op, v.fields));
                }
                else {
                    const v = value;
                    innerFilters.push(exports.Utility._selectorFilterToFlatJSONObj(types_1.SelectorFilterOperator.EQ, v));
                }
            }
        }
        if (filter.logicalFilters) {
            for (const value of filter.logicalFilters)
                innerFilters.push(exports.Utility._logicalFilterToJSONObj(value));
        }
        return result;
    },
    readFieldString(readFields) {
        var _a, _b;
        const include = (_a = readFields.include) === null || _a === void 0 ? void 0 : _a.reduce((acc, field) => (Object.assign(Object.assign({}, acc), { [field]: true })), {});
        const exclude = (_b = readFields.exclude) === null || _b === void 0 ? void 0 : _b.reduce((acc, field) => (Object.assign(Object.assign({}, acc), { [field]: false })), {});
        return this.objToJsonString(Object.assign(Object.assign({}, include), exclude));
    },
    updateFieldsString(updateFields) {
        // UpdateFields
        // eslint-disable-next-line no-prototype-builtins
        if (updateFields.hasOwnProperty("op")) {
            const { op, fields } = updateFields;
            return this.objToJsonString({
                [op]: fields,
            });
        }
        else {
            // SimpleUpdateField
            return exports.Utility.updateFieldsString({
                op: types_1.UpdateFieldsOperator.SET,
                fields: updateFields
            });
        }
    },
    objToJsonString(obj) {
        const JSONbigNative = (0, json_bigint_1.default)({ useNativeBigInt: true });
        return JSONbigNative.stringify(obj);
    },
    jsonStringToObj(json) {
        const JSONbigNative = (0, json_bigint_1.default)({ useNativeBigInt: true });
        return JSONbigNative.parse(json);
    },
    txToMetadata(tx) {
        const metadata = new grpc_js_1.Metadata();
        if (tx !== undefined) {
            metadata.set("Tigris-Tx-Id", tx.id);
            metadata.set("Tigris-Tx-Origin", tx.origin);
            metadata.merge(tx.additionalMetadata);
        }
        return metadata;
    },
    /*
    This method converts nested json object to single level object.
     for example
     {
         "name": "Alice",
         "balance" : 123.123,
         "address": {
            "city": "San Francisco",
            "state": "California"
         }
     }
     gets converted to
     {
         "name": "Alice",
         "balance" : 123.123,
         "address.city": "San Francisco",
         "address.state": "California"
     }

     This is used for filter JSON serialization internally.
    */
    _flattenObj(ob) {
        const toReturn = {};
        for (const key in ob) {
            // eslint-disable-next-line no-prototype-builtins
            if (!ob.hasOwnProperty(key))
                continue;
            if ((typeof ob[key]) == "object" && ob[key] !== null) {
                const flatObject = exports.Utility._flattenObj(ob[key]);
                for (const x in flatObject) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (!flatObject.hasOwnProperty(x))
                        continue;
                    toReturn[key + "." + x] = flatObject[x];
                }
            }
            else {
                toReturn[key] = ob[key];
            }
        }
        return toReturn;
    },
    _toJSONSchema(collectionName, schema) {
        const root = {};
        const pkeyMap = {};
        root["title"] = collectionName;
        root["additionalProperties"] = false;
        root["type"] = "object";
        root["properties"] = this._getSchemaProperties(schema, pkeyMap);
        exports.Utility._postProcessSchema(root, pkeyMap);
        return exports.Utility.objToJsonString(root);
    },
    /*
    TODO:
      - validate the user defined schema (for example look for primary keys with duplicate
      order)
     - this can be extended for other schema massaging
     */
    _postProcessSchema(result, pkeyMap) {
        if (Object.keys(pkeyMap).length === 0) {
            // if no pkeys was used defined. add implicit pkey
            result["properties"]["id"] = {
                "type": "string",
                "format": "uuid"
            };
            result["primary_key"] = ["id"];
        }
        else {
            result["primary_key"] = [];
            // add primary_key in order
            for (let i = 1; i <= Object.keys(pkeyMap).length; i++) {
                result["primary_key"].push(pkeyMap[i.toString()]);
            }
        }
        return result;
    },
    _getSchemaProperties(schema, pkeyMap) {
        const properties = {};
        for (const property of Object.keys(schema)) {
            let thisProperty = {};
            // single flat property? OR the property referring to another type (nested collection)
            if (typeof schema[property].type === "object" || (!(schema[property]["items"] || schema[property]["type"]))) {
                thisProperty["type"] = "object";
                thisProperty["properties"] = this._getSchemaProperties(schema[property]["type"], pkeyMap);
            }
            else if (schema[property].type != types_1.TigrisDataTypes.ARRAY.valueOf()
                && typeof schema[property].type != "object") {
                thisProperty["type"] = this._getType(schema[property].type);
                const format = this._getFormat(schema[property].type);
                if (format) {
                    thisProperty["format"] = format;
                }
                // flat property could be a pkey
                if (schema[property].primary_key) {
                    pkeyMap[schema[property].primary_key["order"]] = property;
                    //  autogenerate?
                    if (schema[property].primary_key["autoGenerate"]) {
                        thisProperty["autoGenerate"] = true;
                    }
                }
                // array type?
            }
            else if (schema[property].type === types_1.TigrisDataTypes.ARRAY.valueOf()) {
                thisProperty = this._getArrayBlock(schema[property], pkeyMap);
            }
            properties[property] = thisProperty;
        }
        return properties;
    },
    _readRequestOptionsToProtoReadRequestOptions(input) {
        const result = new api_pb_1.ReadRequestOptions();
        if (input !== undefined) {
            if (input.skip !== undefined) {
                result.setSkip(input.skip);
            }
            if (input.limit !== undefined) {
                result.setSkip(input.limit);
            }
            if (input.offset !== undefined) {
                result.setOffset(exports.Utility.stringToUint8Array(input.offset));
            }
        }
        return result;
    },
    _getArrayBlock(arraySchema, pkeyMap) {
        const arrayBlock = {};
        arrayBlock["type"] = "array";
        arrayBlock["items"] = {};
        // array of array?
        if (arraySchema["items"]["type"] === types_1.TigrisDataTypes.ARRAY.valueOf()) {
            arrayBlock["items"] = this._getArrayBlock(arraySchema["items"], pkeyMap);
            // array of custom type?
        }
        else if (typeof arraySchema["items"]["type"] === "object") {
            arrayBlock["items"]["type"] = "object";
            arrayBlock["items"]["properties"] = this._getSchemaProperties(arraySchema["items"]["type"], pkeyMap);
            // within array: single flat property?
        }
        else {
            arrayBlock["items"]["type"] = this._getType(arraySchema["items"]["type"]);
            const format = this._getFormat(arraySchema["items"]["type"]);
            if (format) {
                arrayBlock["items"]["format"] = format;
            }
        }
        return arrayBlock;
    },
    _getType(fieldType) {
        switch (fieldType.valueOf()) {
            case types_1.TigrisDataTypes.INT32:
            case types_1.TigrisDataTypes.INT64:
            case types_1.TigrisDataTypes.NUMBER_BIGINT:
                return "integer";
            case types_1.TigrisDataTypes.NUMBER:
                return "number";
            case types_1.TigrisDataTypes.STRING:
            case types_1.TigrisDataTypes.UUID:
            case types_1.TigrisDataTypes.DATE_TIME:
            case types_1.TigrisDataTypes.BYTE_STRING:
                return "string";
        }
        return undefined;
    },
    _getFormat(fieldType) {
        switch (fieldType.valueOf()) {
            case types_1.TigrisDataTypes.INT32:
                return "int32";
            case types_1.TigrisDataTypes.INT64:
                return "int64";
            case types_1.TigrisDataTypes.UUID:
                return "uuid";
            case types_1.TigrisDataTypes.DATE_TIME:
                return "date-time";
            case types_1.TigrisDataTypes.BYTE_STRING:
                return "byte";
        }
        return undefined;
    },
    _readTestDataFile(path) {
        return exports.Utility.objToJsonString(exports.Utility.jsonStringToObj(fs.readFileSync("src/__tests__/data/" + path, "utf8")));
    },
    _base64Encode(input) {
        return Buffer.from(input, "binary").toString("base64");
    },
    _base64Decode(b64String) {
        return Buffer.from(b64String, "base64").toString("binary");
    },
    createFacetQueryOptions(options) {
        const defaults = { size: 10, type: types_2.FacetQueryFieldType.VALUE };
        return Object.assign(Object.assign({}, defaults), options);
    },
    facetQueryToString(facets) {
        if (Array.isArray(facets)) {
            const optionsMap = {};
            for (const f of facets) {
                optionsMap[f] = this.createFacetQueryOptions();
            }
            return this.objToJsonString(optionsMap);
        }
        else {
            return this.objToJsonString(facets);
        }
    },
    sortOrderingToString(ordering) {
        if (ordering === undefined || ordering.length === 0) {
            return "[]";
        }
        const sortOrders = [];
        for (const o of ordering) {
            sortOrders.push({ [o.field]: o.order });
        }
        return this.objToJsonString(sortOrders);
    },
};
