"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DB = void 0;
const types_1 = require("./types");
const api_pb_1 = require("./proto/server/v1/api_pb");
const collection_1 = require("./collection");
const session_1 = require("./session");
const utility_1 = require("./utility");
const grpc_js_1 = require("@grpc/grpc-js");
const topic_1 = require("./topic");
/**
 * Tigris Database
 */
const SetCookie = "Set-Cookie";
const Cookie = "Cookie";
const BeginTransactionMethodName = "/tigrisdata.v1.Tigris/BeginTransaction";
class DB {
    constructor(db, grpcClient) {
        this._db = db;
        this.grpcClient = grpcClient;
    }
    createOrUpdateCollection(collectionName, schema) {
        return this.createOrUpdate(collectionName, schema, () => new collection_1.Collection(collectionName, this._db, this.grpcClient));
    }
    createOrUpdateTopic(topicName, schema) {
        return this.createOrUpdate(topicName, schema, () => new topic_1.Topic(topicName, this._db, this.grpcClient));
    }
    createOrUpdate(name, schema, resolver) {
        return new Promise((resolve, reject) => {
            const rawJSONSchema = utility_1.Utility._toJSONSchema(name, schema);
            console.log(rawJSONSchema);
            const createOrUpdateCollectionRequest = new api_pb_1.CreateOrUpdateCollectionRequest()
                .setDb(this._db)
                .setCollection(name)
                .setOnlyCreate(false)
                .setSchema(utility_1.Utility.stringToUint8Array(rawJSONSchema));
            this.grpcClient.createOrUpdateCollection(createOrUpdateCollectionRequest, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (error, _response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(resolver());
            });
        });
    }
    listCollections(options) {
        return new Promise((resolve, reject) => {
            const request = new api_pb_1.ListCollectionsRequest().setDb(this.db);
            if (typeof options !== "undefined") {
                return request.setOptions(new api_pb_1.CollectionOptions());
            }
            this.grpcClient.listCollections(request, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const result = response
                        .getCollectionsList()
                        .map((collectionInfo) => new types_1.CollectionInfo(collectionInfo.getCollection(), new types_1.CollectionMetadata()));
                    resolve(result);
                }
            });
        });
    }
    dropCollection(collectionName) {
        return new Promise((resolve, reject) => {
            this.grpcClient.dropCollection(new api_pb_1.DropCollectionRequest().setDb(this.db).setCollection(collectionName), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.DropCollectionResponse(response.getStatus(), response.getMessage()));
                }
            });
        });
    }
    describe() {
        return new Promise((resolve, reject) => {
            this.grpcClient.describeDatabase(new api_pb_1.DescribeDatabaseRequest().setDb(this.db), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const collectionsDescription = [];
                    for (let i = 0; i < response.getCollectionsList().length; i++) {
                        collectionsDescription.push(new types_1.CollectionDescription(response.getCollectionsList()[i].getCollection(), new types_1.CollectionMetadata(), response.getCollectionsList()[i].getSchema_asB64()));
                    }
                    resolve(new types_1.DatabaseDescription(response.getDb(), new types_1.DatabaseMetadata(), collectionsDescription));
                }
            });
        });
    }
    getCollection(collectionName) {
        return new collection_1.Collection(collectionName, this.db, this.grpcClient);
    }
    getTopic(topicName) {
        return new topic_1.Topic(topicName, this.db, this.grpcClient);
    }
    transact(fn) {
        return new Promise((resolve, reject) => {
            this.beginTransaction()
                .then((session) => __awaiter(this, void 0, void 0, function* () {
                // tx started
                try {
                    // invoke user code
                    yield fn(session);
                    // user code successful
                    const commitResponse = yield session.commit();
                    if (commitResponse) {
                        resolve(new types_1.TransactionResponse("transaction successful"));
                    }
                }
                catch (error) {
                    // failed to run user code
                    yield session.rollback();
                    // pass error to user
                    reject(error);
                }
            })).catch(error => reject(error));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    beginTransaction(_options) {
        return new Promise((resolve, reject) => {
            const beginTxRequest = new api_pb_1.BeginTransactionRequest().setDb(this._db);
            const cookie = new grpc_js_1.Metadata();
            const call = this.grpcClient.makeUnaryRequest(BeginTransactionMethodName, value => Buffer.from(value.serializeBinary()), value => api_pb_1.BeginTransactionResponse.deserializeBinary(value), beginTxRequest, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    // on metadata is expected to have invoked at this point since response
                    // is served
                    resolve(new session_1.Session(response.getTxCtx().getId(), response.getTxCtx().getOrigin(), this.grpcClient, this.db, cookie));
                }
            });
            call.on("metadata", metadata => {
                if (metadata.get(SetCookie)) {
                    for (const inboundCookie of metadata.get(SetCookie))
                        cookie.add(Cookie, inboundCookie);
                }
            });
        });
    }
    get db() {
        return this._db;
    }
}
exports.DB = DB;
